# ETCD基础
## Part: Raft
- [Raft论文](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)

# ETCD问题
## Q： ETCD存储是如何设计的?

etcd设计用于可靠地存储不经常更新的数据并提供可靠的观察查询。etcd公开了键值对的先前版本，以支持廉价的快照和观察历史事件（“时间旅行查询”）。持久的、多版本的、并发控制的数据模型非常适用于这些用例。

etcd将数据存储在多版本的持久键值存储中。持久键值存储在将其值用新数据取代时保留键值对的先前版本。键值存储实际上是不可变的；其操作不会原地更新结构，而是始终生成一个新的更新后的结构。在修改后，所有过去版本的键仍然可访问和观察。为防止数据存储随着时间无限增长并保留旧版本，存储可以被压缩以丢弃旧版本的被取代数据。

**逻辑视图**

存储的逻辑视图是一个扁平的二进制键空间。key空间上有一个按字节字符串key排序的字典序索引，因此范围查询是cheap的。

key空间保留多个修订revision。当存储被创建时，初始修订版本为1。每个原子变异操作（例如，事务操作可能包含多个操作）都会在键空间上创建一个新的修订版本。所有由先前修订版本持有的数据保持不变。可以通过先前的修订版本仍然访问旧版本的键。同样，修订版本也被索引；使用观察者遍历修订版本是高效的。如果存储被压缩以节省空间，则将删除压缩修订版本之前的修订版本。修订版本在群集的生命周期内是单调递增的。

键的生命周期跨越一个生成，从创建到删除。每个键可以有一个或多个生成。创建键会增加该键的版本，如果该键在当前修订版本中不存在，则从1开始。删除键会生成一个key tombstone，通过将其版本重置为0来结束键的当前生成。每次修改键都会增加其版本；因此，在键的生成内，版本是单调递增的。一旦发生压缩，任何在压缩修订版本之前结束的生成都将被删除，并且在压缩修订版本之前设置的值除了最新值之外都将被删除。

**物理视图**

etcd将物理数据存储为持久化的b+树中的键值对。存储状态的每个修订版本仅包含与其前一个修订版本的增量以提高效率。单个修订版本可能对应于树中的多个键。

k-v pairs的key是一个3元组（major，sub，type）。major是保存key的存储修订revision。sub在同一修订revision中区分键。type是一个特殊值的可选后缀（例如，如果值包含tombstone，则为t）。键值对的值包含自上一个修订版本的修改，因此是从前一个修订版本的增量。b+树按字典顺序的键排序。在修订版本的增量上进行范围查找很快；这使得能够快速找到从一个特定修订版本到另一个修订版本的修改。压缩会删除过时的键值对。

etcd还保留一个辅助内存b树索引，以加速键的范围查询。b树索引中的键是向用户公开的存储的键。值是持久b+树的修改的指针。压缩会删除无用指针。

总的来说，etcd从b树获取修订信息，然后使用修订作为键从b+树中获取值。

(https://etcd.io/docs/v3.5/learning/data_model/)
### Q1 存储的具体实现是什么

## RAFT算法相关问题
### Q1：Raft算法，commitIndex和lastApplied分别是什么意思，有什么区别
Raft算法是一个用于分布式系统的共识算法，其核心目标是确保分布式系统的一致性。在Raft算法中，commitIndex和lastApplied是两个关键的状态变量，它们各自有着不同的意义。

Raft算法是一个用于分布式系统的共识算法，其核心目标是确保分布式系统的一致性。在Raft算法中，`commitIndex`和`lastApplied`是两个关键的状态变量，它们各自有着不同的意义。

1. **commitIndex**:


	* `commitIndex`是Raft算法中的一个关键变量，用于标识当前已经被大多数节点（即超过半数的集群节点）所确认的最高的日志条目的索引。
	* 当一个日志条目被复制到大多数服务器上时，它就被认为是“已提交的”（committed），这意味着这个条目未来一定会被应用到状态机上。
	* `commitIndex`是一个全局的变量，代表了已经被提交的日志条目的最高索引。
2. **lastApplied**:


	* `lastApplied`表示已经被应用到状态机上的最高的日志条目的索引。
	* Raft算法中，当日志条目被提交后，它们需要被应用到节点的本地状态机上。`lastApplied`就用来跟踪这个进度，表示当前哪些条目已经被应用。
	* 每个服务器都会维护自己的`lastApplied`，它记录了该服务器上已经被应用到状态机的最新日志条目的索引。

**区别**:

* `commitIndex`关注的是哪些日志条目已经被集群中的大多数节点确认并可以安全地应用到状态机上，它是一个全局的进度指标。
* `lastApplied`则关注的是在当前节点上，哪些日志条目已经被实际应用到状态机上，它是一个节点本地的进度指标。

在正常情况下，`commitIndex`应该是大于等于`lastApplied`的，因为一个条目在被提交（即`commitIndex`更新）之后，可能还需要一些时间来实际应用到状态机上（即更新`lastApplied`）。

### Q2: Raft算法比起其它共识算法有什么优势?
Raft算法是一个用于实现分布式系统中日志一致性的共识算法，它和Paxos等其他共识算法相比具有一些独特的优势。以下是Raft算法的几个主要优点：

#### 1. **易于理解和实现**
   - **理解性**：Raft算法的主要设计目标之一是易于理解。相比于Paxos，Raft的结构更加直观和简洁，使得开发者更容易理解其工作原理和实现。
   - **实现性**：Raft算法的简单性也使得其实现起来较为直接，减少了在实际部署和维护中出现错误的可能性。

#### 2. **明确的领导者选举**
   - Raft算法通过一个明确的领导者选举过程来协调日志条目的复制和提交，确保了集群的一致性。这种明确的领导者角色简化了日志复制的管理，因为所有的日志条目都是由领导者首先创建并分发给其他节点。

#### 3. **日志复制的简化**
   - 在Raft中，日志条目以一种高效和一致的方式复制到集群中的所有节点。如果发生冲突，Raft算法会自动删除冲突的条目并重新发送新的条目以确保所有节点的日志保持一致。

#### 4. **安全性**
   - Raft算法在设计时特别强调了安全性。例如，它确保了选举的正确性和日志的一致性，不允许已经在一些节点上提交的日志条目被覆盖。

#### 5. **更好的故障处理和可用性**
   - Raft通过心跳机制和定时器来检测节点故障，并快速进行领导者重新选举。这提高了系统对节点故障的响应速度和整体的可用性。

#### 6. **支持更改集群配置**
   - Raft包括了一种用于在线更改集群配置的机制，这使得在不停机的情况下添加或删除节点成为可能。这对于需要动态调整其集群大小的系统来说非常有用。

总之，Raft算法的设计哲学是易于理解和实现，同时提供了强大的功能和高安全性。这些特性使得它在需要高可靠性和易于维护的分布式系统中成为一个非常受欢迎的选择。相比其他算法，Raft提供了一个更为直观和健壮的框架，尤其是在需要清晰管理和故障恢复机制的应用场景中。


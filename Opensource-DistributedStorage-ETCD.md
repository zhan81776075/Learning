# ETCD基础
## Part: Raft
- [Raft论文](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)

# ETCD问题
## Q： ETCD存储是如何设计的?

etcd设计用于可靠地存储不经常更新的数据并提供可靠的观察查询。etcd公开了键值对的先前版本，以支持廉价的快照和观察历史事件（“时间旅行查询”）。持久的、多版本的、并发控制的数据模型非常适用于这些用例。

etcd将数据存储在多版本的持久键值存储中。持久键值存储在将其值用新数据取代时保留键值对的先前版本。键值存储实际上是不可变的；其操作不会原地更新结构，而是始终生成一个新的更新后的结构。在修改后，所有过去版本的键仍然可访问和观察。为防止数据存储随着时间无限增长并保留旧版本，存储可以被压缩以丢弃旧版本的被取代数据。

**逻辑视图**

存储的逻辑视图是一个扁平的二进制键空间。key空间上有一个按字节字符串key排序的字典序索引，因此范围查询是cheap的。

key空间保留多个修订revision。当存储被创建时，初始修订版本为1。每个原子变异操作（例如，事务操作可能包含多个操作）都会在键空间上创建一个新的修订版本。所有由先前修订版本持有的数据保持不变。可以通过先前的修订版本仍然访问旧版本的键。同样，修订版本也被索引；使用观察者遍历修订版本是高效的。如果存储被压缩以节省空间，则将删除压缩修订版本之前的修订版本。修订版本在群集的生命周期内是单调递增的。

键的生命周期跨越一个生成，从创建到删除。每个键可以有一个或多个生成。创建键会增加该键的版本，如果该键在当前修订版本中不存在，则从1开始。删除键会生成一个key tombstone，通过将其版本重置为0来结束键的当前生成。每次修改键都会增加其版本；因此，在键的生成内，版本是单调递增的。一旦发生压缩，任何在压缩修订版本之前结束的生成都将被删除，并且在压缩修订版本之前设置的值除了最新值之外都将被删除。

**物理视图**

etcd将物理数据存储为持久化的b+树中的键值对。存储状态的每个修订版本仅包含与其前一个修订版本的增量以提高效率。单个修订版本可能对应于树中的多个键。

k-v pairs的key是一个3元组（major，sub，type）。major是保存key的存储修订revision。sub在同一修订revision中区分键。type是一个特殊值的可选后缀（例如，如果值包含tombstone，则为t）。键值对的值包含自上一个修订版本的修改，因此是从前一个修订版本的增量。b+树按字典顺序的键排序。在修订版本的增量上进行范围查找很快；这使得能够快速找到从一个特定修订版本到另一个修订版本的修改。压缩会删除过时的键值对。

etcd还保留一个辅助内存b树索引，以加速键的范围查询。b树索引中的键是向用户公开的存储的键。值是持久b+树的修改的指针。压缩会删除无用指针。

总的来说，etcd从b树获取修订信息，然后使用修订作为键从b+树中获取值。

(https://etcd.io/docs/v3.5/learning/data_model/)
### Q1 存储的具体实现是什么
